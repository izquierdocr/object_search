<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ARNL: arnlServer.cpp</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ARNL
   &#160;<span id="projectnumber">1.9.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('arnlServer_8cpp-example.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">arnlServer.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<p>example of almost all ARNL features</p>
<div class="fragment"><pre class="fragment">
<span class="preprocessor">#include &quot;Aria.h&quot;</span>
<span class="preprocessor">#include &quot;ArNetworking.h&quot;</span>
<span class="preprocessor">#include &quot;Arnl.h&quot;</span>
<span class="preprocessor">#include &quot;ArPathPlanningInterface.h&quot;</span>
<span class="preprocessor">#include &quot;ArLocalizationTask.h&quot;</span>
<span class="preprocessor">#include &quot;ArDocking.h&quot;</span>
<span class="preprocessor">#include &quot;ArSystemStatus.h&quot;</span>

<span class="keywordtype">void</span> logOptions(<span class="keyword">const</span> <span class="keywordtype">char</span> *progname)
{
  ArLog::log(ArLog::Normal, <span class="stringliteral">&quot;Usage: %s [options]\n&quot;</span>, progname);
  ArLog::log(ArLog::Normal, <span class="stringliteral">&quot;[options] are any program options listed below, or any ARNL configuration&quot;</span>);
  ArLog::log(ArLog::Normal, <span class="stringliteral">&quot;parameters as -name &lt;value&gt;, see params/arnl.p for list.&quot;</span>);
  ArLog::log(ArLog::Normal, <span class="stringliteral">&quot;For example, -map &lt;map file&gt;.&quot;</span>);
  Aria::logOptions();
}

<span class="keywordtype">bool</span> gyroErrored = <span class="keyword">false</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span>* getGyroStatusString(ArRobot* robot)
{
  <span class="keywordflow">if</span>(!robot || !robot-&gt;getOrigRobotConfig() || robot-&gt;getOrigRobotConfig()-&gt;getGyroType() &lt; 2) <span class="keywordflow">return</span> <span class="stringliteral">&quot;N/A&quot;</span>;
  <span class="keywordflow">if</span>(robot-&gt;getFaultFlags() &amp; ArUtil::BIT4)
  {
    gyroErrored = <span class="keyword">true</span>;
    <span class="keywordflow">return</span> <span class="stringliteral">&quot;ERROR/OFF&quot;</span>;
  }
  <span class="keywordflow">if</span>(gyroErrored)
  {
    <span class="keywordflow">return</span> <span class="stringliteral">&quot;OK but error before&quot;</span>;
  }
  <span class="keywordflow">return</span> <span class="stringliteral">&quot;OK&quot;</span>;
}

<span class="comment">// This function is called from the ArRobot task thread on every robot update,</span>
<span class="comment">// which is every 100ms.  You can check timers here and do any non-blocking</span>
<span class="comment">// monitoring of I/O.  Any long-blocking operations must not be done in this</span>
<span class="comment">// callback however, or it will impact the ArRobot task thread and</span>
<span class="comment">// communications with the robot (use ArASyncTask to run a new thread instead.)</span>
<span class="keywordtype">void</span> robotTaskExample(ArRobot* robot)
{
}

<span class="comment">// This function is called whenever a new goal is reached. It will be attached </span>
<span class="comment">// to the path planning task below in main() via ArPathPlanningTask::addGoalDoneCB()</span>
<span class="keywordtype">void</span> goalDone(ArPose goalPos) <span class="comment">//, ArPathPlanningTask *pathTask)</span>
{
  ArLog::log(ArLog::Normal, <span class="stringliteral">&quot;ARNL server example: goal reached&quot;</span>);
}

<span class="comment">// This function is called if pathplanning fails. It will be attached </span>
<span class="comment">// to the path planning task below in main() via</span>
<span class="comment">// ArPathPlanningTask::addGoalFailedCB()</span>
<span class="keywordtype">void</span> goalFailed(ArPose goalPos) <span class="comment">//, ArPathPlanningTask *pathTask)</span>
{
  ArLog::log(ArLog::Normal, <span class="stringliteral">&quot;ARNL server example: goal failed&quot;</span>);
}

<span class="comment">// This function is called if localization fails. It will be attached </span>
<span class="comment">// to the localization task below in main() via</span>
<span class="comment">// ArLocalizationTask::setFailedCallback()</span>
<span class="keywordtype">void</span> locFailed(<span class="keywordtype">int</span> n) <span class="comment">//, ArLocalizationTask* locTask)</span>
{
  ArLog::log(ArLog::Normal, <span class="stringliteral">&quot;ARNL server example: localization failed&quot;</span>);
}
 
<span class="comment">// This function is called whenever the path planning task changes its state</span>
<span class="comment">// (for example, from idle to planning a path, to following a planned path). It will be attached </span>
<span class="comment">// to the path planning task below in main() via</span>
<span class="comment">// ArPathPlanningTask::addStateChangeCB()</span>
<span class="comment">//ArPathPlanningInterface *pathPlanningTask = NULL;</span>
<span class="keywordtype">void</span> pathPlanStateChanged(<a name="_a0"></a><a class="codeRef" doxygen="BaseArnl.tag:../BaseArnl-Reference//" href="../BaseArnl-Reference/classArPathPlanningTask.html">ArPathPlanningTask</a> *pathPlanningTask)
{
  <span class="keywordtype">char</span> s[256];
  pathPlanningTask-&gt;<a name="a1"></a><a class="codeRef" doxygen="BaseArnl.tag:../BaseArnl-Reference//" href="../BaseArnl-Reference/classArPathPlanningTask.html#ab7e75be74d6295850fdb8b20551883c7">getFailureString</a>(s, 256);
  ArLog::log(ArLog::Normal, <span class="stringliteral">&quot;ARNL server example: Path planning state: %s&quot;</span>, s);
}


<span class="keyword">class </span>RobotMonitor
{
<span class="keyword">protected</span>:
  ArRobot *robot;
  ArServerHandlerPopup *popupServer;
  ArTypes::Byte4 motorsDisabledPopupID;
  ArServerHandlerPopupInfo motorsDisabledPopupInfo;
  ArFunctor2C&lt;RobotMonitor, ArTypes::Byte4, int&gt; handleMotorsDisabledPopupResponseCB;
  ArFunctorC&lt;RobotMonitor&gt; robotMonitorCB;

<span class="keyword">public</span>:
  RobotMonitor(ArRobot *r, ArServerHandlerPopup *ps) :
    robot(r),
    popupServer(ps),
    motorsDisabledPopupID(0),
    motorsDisabledPopupInfo( NULL,
      <span class="stringliteral">&quot;Robot Motors Are Disabled&quot;</span>,
      <span class="stringliteral">&quot;The robot&#39;s motors are disabled&quot;</span>, 
      ArServerHandlerPopup::WARNING,
      1,  <span class="comment">// default button ID</span>
      0,  <span class="comment">// escape button ID</span>
      -1, <span class="comment">// timeout</span>
      NULL, <span class="comment">// timeout message</span>
      <span class="stringliteral">&quot;Enable Motors&quot;</span>, <span class="stringliteral">&quot;Enabling Motors...&quot;</span>,
      <span class="stringliteral">&quot;Ignore&quot;</span>, <span class="stringliteral">&quot;Ignore&quot;</span>
    ),
    handleMotorsDisabledPopupResponseCB(this, &amp;RobotMonitor::handleMotorsDisabledResponse),
    robotMonitorCB(this, &amp;RobotMonitor::robotMonitorTask)
  {
    robot-&gt;addUserTask(<span class="stringliteral">&quot;arnlServerRobotMonitor&quot;</span>, 30, &amp;robotMonitorCB);
  }

  ~RobotMonitor()
  {
    robot-&gt;remUserTask(&amp;robotMonitorCB);
  }

<span class="keyword">protected</span>:
  <span class="keywordtype">void</span> handleMotorsDisabledResponse(ArTypes::Byte4 popupID, <span class="keywordtype">int</span> button)
  {
    <span class="keywordflow">if</span>(button == 0)
    {
      ArLog::log(ArLog::Normal, <span class="stringliteral">&quot;Enabling motors...&quot;</span>);
      robot-&gt;enableMotors();
    }
    popupServer-&gt;closePopup(motorsDisabledPopupID, <span class="stringliteral">&quot;Closing motor disable popup.&quot;</span>);
    motorsDisabledPopupID = 0;
  }


  <span class="comment">// This function is called as a robot task (every 100ms) to check on the robot</span>
  <span class="comment">// state and perform feedback and interact with user as needed.</span>
  <span class="keywordtype">void</span> robotMonitorTask()
  {

    <span class="comment">// a way for user to re-enable motors if disabled -- show a popup dialog in</span>
    <span class="comment">// MobileEyes.</span>
    <span class="keywordflow">if</span>(motorsDisabledPopupID == 0 &amp;&amp; robot &amp;&amp; !robot-&gt;areMotorsEnabled() &amp;&amp; robot-&gt;isConnected())
    {
      motorsDisabledPopupID = popupServer-&gt;createPopup(&amp;motorsDisabledPopupInfo, &amp;handleMotorsDisabledPopupResponseCB);
    }

    <span class="comment">// Set LX wheel light pattern based on robot activity. You could add more</span>
    <span class="comment">// conditions/light patterns here if you want.</span>
    <span class="keywordflow">if</span>(robot-&gt;isEStopPressed())
      robot-&gt;comDataN(ArCommands::WHEEL_LIGHT, <span class="stringliteral">&quot;\x02\0\0\0&quot;</span>, 4); <span class="comment">// pattern #2, flash red</span>
    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(!robot-&gt;areMotorsEnabled())
      robot-&gt;comDataN(ArCommands::WHEEL_LIGHT, <span class="stringliteral">&quot;\x03\0\0\0&quot;</span>, 4); <span class="comment">// pattern #3, flash yellow</span>
    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(fabs(robot-&gt;getVel()) &lt; 5)
      robot-&gt;comDataN(ArCommands::WHEEL_LIGHT, <span class="stringliteral">&quot;\x0A\0\0\0&quot;</span>, 4);  <span class="comment">// pattern #10, slow blue flash</span>
    <span class="keywordflow">else</span>
      robot-&gt;comDataN(ArCommands::WHEEL_LIGHT, <span class="stringliteral">&quot;\x09\0\0\0&quot;</span>, 4);  <span class="comment">// pattern 9, blue sweep.</span>
    
  }
};


<span class="keywordtype">bool</span> handleDebugMessage(ArRobotPacket *pkt)
{
  <span class="keywordflow">if</span>(pkt-&gt;getID() != ArCommands::MARCDEBUG) <span class="keywordflow">return</span> <span class="keyword">false</span>;
  <span class="keywordtype">char</span> msg[256];
  pkt-&gt;bufToStr(msg, <span class="keyword">sizeof</span>(msg));
  msg[255] = 0;
  ArLog::log(ArLog::Terse, <span class="stringliteral">&quot;Controller Firmware: %s&quot;</span>, msg);
  <span class="keywordflow">return</span> <span class="keyword">true</span>;
}


<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
{
  <span class="comment">// Initialize Aria and Arnl global information</span>
  Aria::init();
  Arnl::init();

  <span class="comment">// You can change default ArLog options in this call, but the settings in the parameter file</span>
  <span class="comment">// (arnl.p) which is loaded below (Aria::getConfig()-&gt;parseFile())  will override the options.</span>
  <span class="comment">//ArLog::init(ArLog::File, ArLog::Normal, &quot;log.txt&quot;, true, true);</span>

  <span class="comment">// Used to parse the command line arguments.</span>
  ArArgumentParser parser(&amp;argc, argv);
  
  <span class="comment">// Load default arguments for this computer (from /etc/Aria.args, environment</span>
  <span class="comment">// variables, and other places)</span>
  parser.loadDefaultArguments();

  <span class="comment">// Tell the laser connector to always connect the first laser since</span>
  <span class="comment">// this program always requires a laser.</span>
  parser.addDefaultArgument(<span class="stringliteral">&quot;-connectLaser&quot;</span>);

  


  <span class="comment">// The robot object</span>
  ArRobot robot;

  <span class="comment">// This is an example of a user task callback. This is called every ArRobot</span>
  <span class="comment">// task cycle (every 100ms). The function is defined at the top of this file.</span>
  ArGlobalFunctor1&lt;ArRobot*&gt; robotTaskExampleCB(&amp;robotTaskExample, &amp;robot);
  robot.addUserTask(<span class="stringliteral">&quot;arnlServerExampleTask&quot;</span>, 10, &amp;robotTaskExampleCB);

  <span class="comment">// handle messages from robot controller firmware and log the contents</span>
  robot.addPacketHandler(<span class="keyword">new</span> ArGlobalRetFunctor1&lt;bool, ArRobotPacket*&gt;(&amp;handleDebugMessage));

  <span class="comment">// This object is used to connect to the robot, which can be configured via</span>
  <span class="comment">// command line arguments.</span>
  ArRobotConnector robotConnector(&amp;parser, &amp;robot);

  <span class="comment">// Connect to the robot</span>
  <span class="keywordflow">if</span> (!robotConnector.connectRobot())
  {
    ArLog::log(ArLog::Normal, <span class="stringliteral">&quot;Error: Could not connect to robot... exiting&quot;</span>);
    Aria::exit(3);
  }



  <span class="comment">// Set up where we&#39;ll look for files. Arnl::init() set Aria&#39;s default</span>
  <span class="comment">// directory to Arnl&#39;s default directory; addDirectories() appends this</span>
  <span class="comment">// &quot;examples&quot; directory.</span>
  <span class="keywordtype">char</span> fileDir[1024];
  ArUtil::addDirectories(fileDir, <span class="keyword">sizeof</span>(fileDir), Aria::getDirectory(), 
             <span class="stringliteral">&quot;examples&quot;</span>);
  
  
  <span class="comment">// To direct log messages to a file, or to change the log level, use these  calls:</span>
  <span class="comment">//ArLog::init(ArLog::File, ArLog::Normal, &quot;log.txt&quot;, true, true);</span>
  <span class="comment">//ArLog::init(ArLog::File, ArLog::Verbose);</span>
 
  <span class="comment">// Add a section to the configuration to change ArLog parameters</span>
  ArLog::addToConfig(Aria::getConfig());

  <span class="comment">// set up a gyro (if the robot is older and its firmware does not</span>
  <span class="comment">// automatically incorporate gyro corrections, then this object will do it)</span>
  ArAnalogGyro gyro(&amp;robot);

  <span class="comment">// Our networking server</span>
  ArServerBase server;
  

  <span class="comment">// Set up our simpleOpener, used to set up the networking server</span>
  ArServerSimpleOpener simpleOpener(&amp;parser);

  <span class="comment">// the laser connector</span>
  ArLaserConnector laserConnector(&amp;parser, &amp;robot, &amp;robotConnector);

  <span class="comment">// used to connect to camera PTZ control</span>
  ArPTZConnector ptzConnector(&amp;parser, &amp;robot);

  <span class="comment">// Used to connect to a &quot;central server&quot; which can be used as a proxy </span>
  <span class="comment">// for multiple robot servers, and as a way for them to also communicate with</span>
  <span class="comment">// each other.  (objects implementing some of these inter-robot communication</span>
  <span class="comment">// features are created below).  </span>
  <span class="comment">// NOTE: If the central server is running on the same host as robot server(s),</span>
  <span class="comment">// then you must use the -serverPort argument to instruct these robot-control</span>
  <span class="comment">// server(s) to use different ports than the default 7272, since the central</span>
  <span class="comment">// server will use that port.</span>
  ArClientSwitchManager clientSwitch(&amp;server, &amp;parser);
  
  <span class="comment">// Load default arguments for this computer (from /etc/Aria.args, environment</span>
  <span class="comment">// variables, and other places)</span>
  parser.loadDefaultArguments();

  <span class="comment">// Parse arguments </span>
  <span class="keywordflow">if</span> (!Aria::parseArgs() || !parser.checkHelpAndWarnUnparsed())
  {
    logOptions(argv[0]);
    Aria::exit(1);
  }
  

  <span class="comment">// This causes Aria::exit(9) to be called if the robot unexpectedly</span>
  <span class="comment">// disconnects</span>
  ArGlobalFunctor1&lt;int&gt; shutdownFunctor(&amp;Aria::exit, 9);
  robot.addDisconnectOnErrorCB(&amp;shutdownFunctor);


  <span class="comment">// Create an ArSonarDevice object (ArRangeDevice subclass) and </span>
  <span class="comment">// connect it to the robot.</span>
  ArSonarDevice sonarDev;
  robot.addRangeDevice(&amp;sonarDev);



  <span class="comment">// This object will allow robot&#39;s movement parameters to be changed through</span>
  <span class="comment">// a Robot Configuration section in the ArConfig global configuration facility.</span>
  ArRobotConfig robotConfig(&amp;robot);

  <span class="comment">// Include gyro configuration options in the robot configuration section.</span>
  robotConfig.addAnalogGyro(&amp;gyro);

  <span class="comment">// Start the robot thread.</span>
  robot.runAsync(<span class="keyword">true</span>);

  

  <span class="comment">// connect the laser(s) if it was requested, this adds them to the</span>
  <span class="comment">// robot too, and starts them running in their own threads</span>
  ArLog::log(ArLog::Normal, <span class="stringliteral">&quot;Connecting to laser(s) configured in parameters...&quot;</span>);
  <span class="keywordflow">if</span> (!laserConnector.connectLasers())
  {
    ArLog::log(ArLog::Normal, <span class="stringliteral">&quot;Error: Could not connect to laser(s). Exiting.&quot;</span>);
    Aria::exit(2);
  }
  ArLog::log(ArLog::Normal, <span class="stringliteral">&quot;Done connecting to laser(s).&quot;</span>);

  <span class="comment">// find the laser we should use for localization and/or mapping,</span>
  <span class="comment">// which will be the first laser</span>
  robot.lock();
  ArLaser *firstLaser = robot.findLaser(1);
  <span class="keywordflow">if</span> (firstLaser == NULL || !firstLaser-&gt;isConnected())
  {
    ArLog::log(ArLog::Normal, <span class="stringliteral">&quot;Did not have laser 1 or it is not connected, cannot start localization and/or mapping... exiting&quot;</span>);
    Aria::exit(2);
  }
  robot.unlock();


    <span class="comment">/* Create and set up map object */</span>
  
  <span class="comment">// Set up the map object, this will look for files in the examples</span>
  <span class="comment">// directory (unless the file name starts with a /, \, or .</span>
  <span class="comment">// You can take out the &#39;fileDir&#39; argument to look in the program&#39;s current directory</span>
  <span class="comment">// instead.</span>
  <span class="comment">// When a configuration file is loaded into ArConfig later, if it specifies a</span>
  <span class="comment">// map file, then that file will be loaded as the map.</span>
  ArMap map(fileDir);
  <span class="comment">// set it up to ignore empty file names (otherwise if a configuration omits</span>
  <span class="comment">// the map file, the whole configuration change will fail)</span>
  map.setIgnoreEmptyFileName(<span class="keyword">true</span>);
  <span class="comment">// ignore the case, so that if someone is using MobileEyes or</span>
  <span class="comment">// MobilePlanner from Windows and changes the case on a map name,</span>
  <span class="comment">// it will still work.</span>
  map.setIgnoreCase(<span class="keyword">true</span>);

    
    <span class="comment">/* Create localization and path planning threads */</span>


  <a class="codeRef" doxygen="BaseArnl.tag:../BaseArnl-Reference//" href="../BaseArnl-Reference/classArPathPlanningTask.html">ArPathPlanningTask</a> pathTask(&amp;robot, &amp;sonarDev, &amp;map);
<span class="comment">//  pathPlanningTask = &amp;pathTask;</span>

  <span class="comment">// The following are callback functions that pathTask will call </span>
  <span class="comment">// on certain events such as reaching a goal, failing to reach a goal, etc.</span>
  <span class="comment">// The functions are defined at the top of this file. You can add code there</span>
  <span class="comment">// to take some action such as control something on the robot, choose the next</span>
  <span class="comment">// goal, send output elsewhele, etc.</span>
  ArGlobalFunctor1&lt;ArPose&gt; <span class="comment">/*, ArPathPlanningTask*&gt;*/</span> goalDoneCB(&amp;goalDone); <span class="comment">//, &amp;pathTask);</span>
  pathTask.addGoalDoneCB(&amp;goalDoneCB);

  ArGlobalFunctor1&lt;ArPose&gt; <span class="comment">/*, ArPathPlanningTask*&gt;*/</span> goalFailedCB(&amp;goalFailed); <span class="comment">//, &amp;pathTask);</span>
  pathTask.addGoalFailedCB(&amp;goalFailedCB);

  ArGlobalFunctor1&lt;ArPathPlanningTask*&gt; stateCB(&amp;pathPlanStateChanged, &amp;pathTask);
  pathTask.addStateChangeCB(&amp;stateCB);


  ArLog::log(ArLog::Normal, <span class="stringliteral">&quot;Creating laser localization task&quot;</span>);
  <span class="comment">// Laser Monte-Carlo Localization</span>
  <a name="_a2"></a><a class="code" href="classArLocalizationTask.html" title="Task that performs continuous localization of the robot with a laser range sensor in a seperate async...">ArLocalizationTask</a> locTask(&amp;robot, firstLaser, &amp;map);
  


  <span class="comment">// A callback function, which is called if localization fails</span>
  ArGlobalFunctor1&lt;int&gt; locFailedCB(&amp;locFailed);
  locTask.setFailedCallBack(&amp;locFailedCB); <span class="comment">//, &amp;locTask);</span>


  <span class="comment">// Set some options  and callbacks on each laser that the laser connector </span>
  <span class="comment">// connected to.</span>
  std::map&lt;int, ArLaser *&gt;::iterator laserIt;
  <span class="keywordflow">for</span> (laserIt = robot.getLaserMap()-&gt;begin();
       laserIt != robot.getLaserMap()-&gt;end();
       laserIt++)
  {
    <span class="keywordtype">int</span> laserNum = (*laserIt).first;
    ArLaser *laser = (*laserIt).second;

    <span class="comment">// Skip lasers that aren&#39;t connected</span>
    <span class="keywordflow">if</span>(!laser-&gt;isConnected())
      <span class="keywordflow">continue</span>;

    <span class="comment">// add the disconnectOnError CB to shut things down if the laser</span>
    <span class="comment">// connection is lost</span>
    laser-&gt;addDisconnectOnErrorCB(&amp;shutdownFunctor);
    <span class="comment">// set the number of cumulative readings the laser will take</span>
    laser-&gt;setCumulativeBufferSize(200);
    <span class="comment">// add the lasers to the path planning task</span>
    pathTask.addRangeDevice(laser, <a name="a3"></a><a class="codeRef" doxygen="BaseArnl.tag:../BaseArnl-Reference//" href="../BaseArnl-Reference/classArPathPlanningTask.html#a875d3414ba11ffb584fcb0a71925c9c1a7c8d8c749a1ac37018a7fe136b7a1fc7">ArPathPlanningTask::BOTH</a>);
    <span class="comment">// set the cumulative clean offset (so that they don&#39;t all fire at once)</span>
    laser-&gt;setCumulativeCleanOffset(laserNum * 100);
    <span class="comment">// reset the cumulative clean time (to make the new offset take effect)</span>
    laser-&gt;resetLastCumulativeCleanTime();

    <span class="comment">// Add the packet count to the Aria info strings (It will be included in</span>
    <span class="comment">// MobileEyes custom details so you can monitor whether the laser data is</span>
    <span class="comment">// being received correctly)</span>
    std::string laserPacketCountName;
    laserPacketCountName = laser-&gt;getName();
    laserPacketCountName += <span class="stringliteral">&quot; Packet Count&quot;</span>;
    Aria::getInfoGroup()-&gt;addStringInt(
        laserPacketCountName.c_str(), 10, 
        <span class="keyword">new</span> ArRetFunctorC&lt;int, ArLaser&gt;(laser, 
                     &amp;ArLaser::getReadingCount));
  }





    <span class="comment">/* Start the server */</span>

  <span class="comment">// Open the networking server</span>
  <span class="keywordflow">if</span> (!simpleOpener.open(&amp;server, fileDir, 240))
  {
    ArLog::log(ArLog::Normal, <span class="stringliteral">&quot;Error: Could not open server.&quot;</span>);
    exit(2);
  }



    <span class="comment">/* Create various services that provide network access to clients (such as</span>
<span class="comment">     * MobileEyes), as well as add various additional features to ARNL */</span>


  <span class="comment">// ARNL can optionally get information about the positions of other robots from a</span>
  <span class="comment">// &quot;central server&quot; (see central server example program), if command</span>
  <span class="comment">// line options specifying the address of the central server was given.</span>
  <span class="comment">// If there is no central server, then the address of each other robot</span>
  <span class="comment">// can instead be given in the configuration, and the multirobot systems</span>
  <span class="comment">// will connect to each robot (or &quot;peer&quot;) individually.</span>

        <span class="comment">// TODO move this to multirobot example?</span>
  <a name="_a4"></a><a class="codeRef" doxygen="BaseArnl.tag:../BaseArnl-Reference//" href="../BaseArnl-Reference/classArServerHandlerMultiRobot.html">ArServerHandlerMultiRobot</a> *handlerMultiRobot = NULL;
  <a name="_a5"></a><a class="codeRef" doxygen="BaseArnl.tag:../BaseArnl-Reference//" href="../BaseArnl-Reference/classArMultiRobotRangeDevice.html">ArMultiRobotRangeDevice</a> *multiRobotRangeDevice = NULL;
  <a name="_a6"></a><a class="codeRef" doxygen="BaseArnl.tag:../BaseArnl-Reference//" href="../BaseArnl-Reference/classArServerHandlerMultiRobotPeer.html">ArServerHandlerMultiRobotPeer</a> *multiRobotPeer = NULL;
  <a name="_a7"></a><a class="codeRef" doxygen="BaseArnl.tag:../BaseArnl-Reference//" href="../BaseArnl-Reference/classArMultiRobotPeerRangeDevice.html">ArMultiRobotPeerRangeDevice</a> *multiRobotPeerRangeDevice = NULL;


  <span class="keywordtype">bool</span> usingCentralServer = <span class="keyword">false</span>;
  <span class="keywordflow">if</span>(clientSwitch.getCentralServerHostName() != NULL)
    usingCentralServer = <span class="keyword">true</span>;

  <span class="comment">// if we&#39;re using the central server then we want to create the</span>
  <span class="comment">// multiRobot central classes</span>
  <span class="keywordflow">if</span> (usingCentralServer)
  {
    <span class="comment">// Make the handler for multi robot information (this sends the</span>
    <span class="comment">// information to the central server)</span>
    handlerMultiRobot = <span class="keyword">new</span> <a class="codeRef" doxygen="BaseArnl.tag:../BaseArnl-Reference//" href="../BaseArnl-Reference/classArServerHandlerMultiRobot.html">ArServerHandlerMultiRobot</a>(&amp;server, &amp;robot, 
                              &amp;pathTask,
                              &amp;locTask, &amp;map);
    
    <span class="comment">// Normally each robot, and the central server, must all have</span>
    <span class="comment">// the same map name for the central server to share robot</span>
    <span class="comment">// information.  (i.e. they are operating in the same space).</span>
    <span class="comment">// This changes the map name that ArServerHandlerMutliRobot </span>
    <span class="comment">// reports to the central server, in case you want this individual</span>
    <span class="comment">// robot to load a different map file name, but still report </span>
    <span class="comment">// the common map file to the central server.</span>
    <span class="comment">//handlerMultiRobot-&gt;overrideMapName(&quot;central.map&quot;);</span>

    <span class="comment">// the range device that gets the multi robot information from</span>
    <span class="comment">// the central server and presents it as virtual range readings</span>
    <span class="comment">// to ARNL</span>
    multiRobotRangeDevice = <span class="keyword">new</span> <a class="codeRef" doxygen="BaseArnl.tag:../BaseArnl-Reference//" href="../BaseArnl-Reference/classArMultiRobotRangeDevice.html">ArMultiRobotRangeDevice</a>(&amp;server);
    
    robot.addRangeDevice(multiRobotRangeDevice);
    pathTask.addRangeDevice(multiRobotRangeDevice, 
                <a class="codeRef" doxygen="BaseArnl.tag:../BaseArnl-Reference//" href="../BaseArnl-Reference/classArPathPlanningTask.html#a875d3414ba11ffb584fcb0a71925c9c1a7c8d8c749a1ac37018a7fe136b7a1fc7">ArPathPlanningTask::BOTH</a>);
    
    <span class="comment">// Set up options for drawing multirobot information in MobileEyes.</span>
    multiRobotRangeDevice-&gt;setCurrentDrawingData(
        <span class="keyword">new</span> ArDrawingData(<span class="stringliteral">&quot;polyDots&quot;</span>, ArColor(125, 125, 0),
                  100, 73, 1000), <span class="keyword">true</span>);
    multiRobotRangeDevice-&gt;setCumulativeDrawingData(
        <span class="keyword">new</span> ArDrawingData(<span class="stringliteral">&quot;polyDots&quot;</span>, ArColor(125, 0, 125),
                  100, 72, 1000), <span class="keyword">true</span>);

    <span class="comment">// This sets up the localization to use the known poses of other robots</span>
    <span class="comment">// for its localization in cases where numerous robots crowd out the map.</span>
    locTask.setMultiRobotCallback(multiRobotRangeDevice-&gt;<a name="a8"></a><a class="codeRef" doxygen="BaseArnl.tag:../BaseArnl-Reference//" href="../BaseArnl-Reference/classArMultiRobotRangeDevice.html#aeb6c8d345636af7182e51cabe2df1b83">getOtherRobotsCB</a>());
  }
  <span class="comment">// if we&#39;re not using a central server then create the multirobot peer classes</span>
  <span class="keywordflow">else</span>
  {
    <span class="comment">// set the path planning so it uses the explicit collision range for how far its planning</span>
    pathTask.setUseCollisionRangeForPlanningFlag(<span class="keyword">true</span>);
    <span class="comment">// make our thing that gathers information from the other servers</span>
    multiRobotPeerRangeDevice = <span class="keyword">new</span> <a class="codeRef" doxygen="BaseArnl.tag:../BaseArnl-Reference//" href="../BaseArnl-Reference/classArMultiRobotPeerRangeDevice.html">ArMultiRobotPeerRangeDevice</a>(&amp;map);
    <span class="comment">// make our thing that sends information to the other servers</span>
    multiRobotPeer = <span class="keyword">new</span> <a class="codeRef" doxygen="BaseArnl.tag:../BaseArnl-Reference//" href="../BaseArnl-Reference/classArServerHandlerMultiRobotPeer.html">ArServerHandlerMultiRobotPeer</a>(&amp;server, &amp;robot, 
                             &amp;pathTask, &amp;locTask);
    <span class="comment">// hook the two together so they both know what priority this robot is</span>
    multiRobotPeer-&gt;<a name="a9"></a><a class="codeRef" doxygen="BaseArnl.tag:../BaseArnl-Reference//" href="../BaseArnl-Reference/classArServerHandlerMultiRobotPeer.html#a41d76e1cf09c11ba4a5a091e0bcd9992">setNewPrecedenceCallback</a>(
        multiRobotPeerRangeDevice-&gt;<a name="a10"></a><a class="codeRef" doxygen="BaseArnl.tag:../BaseArnl-Reference//" href="../BaseArnl-Reference/classArMultiRobotPeerRangeDevice.html#a4d1ff5b1f6c7e3a61ba8eaec9ea42803">getSetPrecedenceCallback</a>());
    <span class="comment">// hook the two together so they both know what priority this</span>
    <span class="comment">// robot&#39;s fingerprint is</span>
    multiRobotPeer-&gt;<a name="a11"></a><a class="codeRef" doxygen="BaseArnl.tag:../BaseArnl-Reference//" href="../BaseArnl-Reference/classArServerHandlerMultiRobotPeer.html#a6fe069603090bec27e0ac1e383f451a4">setNewFingerprintCallback</a>(
        multiRobotPeerRangeDevice-&gt;<a name="a12"></a><a class="codeRef" doxygen="BaseArnl.tag:../BaseArnl-Reference//" href="../BaseArnl-Reference/classArMultiRobotPeerRangeDevice.html#a1709c9aff3f282e000900d2bfd9bfba1">getSetFingerprintCallback</a>());
    <span class="comment">// hook the two together so that the range device can call on the</span>
    <span class="comment">// server handler to change its fingerprint</span>
    multiRobotPeerRangeDevice-&gt;<a name="a13"></a><a class="codeRef" doxygen="BaseArnl.tag:../BaseArnl-Reference//" href="../BaseArnl-Reference/classArMultiRobotPeerRangeDevice.html#a492da428dc71b98d67fc0d0665c07b68">setChangeFingerprintCB</a>(
        multiRobotPeer-&gt;<a name="a14"></a><a class="codeRef" doxygen="BaseArnl.tag:../BaseArnl-Reference//" href="../BaseArnl-Reference/classArServerHandlerMultiRobotPeer.html#a079e09af3fc03403b949643f067aac41">getChangeFingerprintCB</a>());
    <span class="comment">// then add the robot to the places it needs to be</span>
    robot.addRangeDevice(multiRobotPeerRangeDevice);
    pathTask.addRangeDevice(multiRobotPeerRangeDevice, 
                <a class="codeRef" doxygen="BaseArnl.tag:../BaseArnl-Reference//" href="../BaseArnl-Reference/classArPathPlanningTask.html#a875d3414ba11ffb584fcb0a71925c9c1a7c8d8c749a1ac37018a7fe136b7a1fc7">ArPathPlanningTask::BOTH</a>);

    <span class="comment">// Set the range device so that we can see the information its using</span>
    <span class="comment">// to avoid, you can comment these out in order to not see them</span>
    multiRobotPeerRangeDevice-&gt;setCurrentDrawingData(
        <span class="keyword">new</span> ArDrawingData(<span class="stringliteral">&quot;polyDots&quot;</span>, ArColor(125, 125, 0),
                  100, 72, 1000), <span class="keyword">true</span>);
    multiRobotPeerRangeDevice-&gt;setCumulativeDrawingData(
        <span class="keyword">new</span> ArDrawingData(<span class="stringliteral">&quot;polyDots&quot;</span>, ArColor(125, 0, 125),
                  100, 72, 1000), <span class="keyword">true</span>);
    <span class="comment">// This sets up the localization to use the known poses of other robots</span>
    <span class="comment">// for its localization in cases where numerous robots crowd out the map.</span>
    locTask.setMultiRobotCallback(
        multiRobotPeerRangeDevice-&gt;<a name="a15"></a><a class="codeRef" doxygen="BaseArnl.tag:../BaseArnl-Reference//" href="../BaseArnl-Reference/classArMultiRobotPeerRangeDevice.html#a8e58c9d9bd524b03a96a4149aa3b1500">getOtherRobotsCB</a>());
  }




  <span class="comment">/* Add additional range devices to the robot and path planning task (so it</span>
<span class="comment">     avoids obstacles detected by these devices) */</span>
  
  <span class="comment">// Add IR range device to robot and path planning task (so it avoids obstacles</span>
  <span class="comment">// detected by this device)</span>
  robot.lock();
  ArIRs irs;
  robot.addRangeDevice(&amp;irs);
  pathTask.addRangeDevice(&amp;irs, <a name="a16"></a><a class="codeRef" doxygen="BaseArnl.tag:../BaseArnl-Reference//" href="../BaseArnl-Reference/classArPathPlanningTask.html#a875d3414ba11ffb584fcb0a71925c9c1a2a5147c60a29a83554a68187a46bfad5">ArPathPlanningTask::CURRENT</a>);

  <span class="comment">// Add bumpers range device to robot and path planning task (so it avoids obstacles</span>
  <span class="comment">// detected by this device)</span>
  ArBumpers bumpers;
  robot.addRangeDevice(&amp;bumpers);
  pathTask.addRangeDevice(&amp;bumpers, <a class="codeRef" doxygen="BaseArnl.tag:../BaseArnl-Reference//" href="../BaseArnl-Reference/classArPathPlanningTask.html#a875d3414ba11ffb584fcb0a71925c9c1a2a5147c60a29a83554a68187a46bfad5">ArPathPlanningTask::CURRENT</a>);

  <span class="comment">// Add range device which uses forbidden regions given in the map to give virtual</span>
  <span class="comment">// range device readings to ARNL.  (so it avoids obstacles</span>
  <span class="comment">// detected by this device)</span>
  ArForbiddenRangeDevice forbidden(&amp;map);
  robot.addRangeDevice(&amp;forbidden);
  pathTask.addRangeDevice(&amp;forbidden, <a class="codeRef" doxygen="BaseArnl.tag:../BaseArnl-Reference//" href="../BaseArnl-Reference/classArPathPlanningTask.html#a875d3414ba11ffb584fcb0a71925c9c1a2a5147c60a29a83554a68187a46bfad5">ArPathPlanningTask::CURRENT</a>);

  robot.unlock();


  <span class="comment">// Action to slow down robot when localization score drops but not lost.</span>
  ArActionSlowDownWhenNotCertain actionSlowDown(&amp;locTask);
  pathTask.getPathPlanActionGroup()-&gt;addAction(&amp;actionSlowDown, 140);

  <span class="comment">// Action to stop the robot when localization is &quot;lost&quot; (score too low)</span>
  <a name="_a17"></a><a class="codeRef" doxygen="BaseArnl.tag:../BaseArnl-Reference//" href="../BaseArnl-Reference/classArActionLost.html">ArActionLost</a> actionLostPath(&amp;locTask, &amp;pathTask);
  pathTask.getPathPlanActionGroup()-&gt;addAction(&amp;actionLostPath, 150);

  <span class="comment">// Arnl uses this object when it must replan its path because its</span>
  <span class="comment">// path is completely blocked.  It will use an older history of sensor</span>
  <span class="comment">// readings to replan this new path.  This should not be used with SONARNL</span>
  <span class="comment">// since sonar readings are not accurate enough and may prevent the robot</span>
  <span class="comment">// from planning through space that is actually clear.</span>
  <a name="_a18"></a><a class="codeRef" doxygen="BaseArnl.tag:../BaseArnl-Reference//" href="../BaseArnl-Reference/classArGlobalReplanningRangeDevice.html">ArGlobalReplanningRangeDevice</a> replanDev(&amp;pathTask);

  
  <span class="comment">// Service to provide drawings of data in the map display :</span>
  ArServerInfoDrawings drawings(&amp;server);
  drawings.addRobotsRangeDevices(&amp;robot);
  drawings.addRangeDevice(&amp;replanDev);

  <span class="comment">/* Draw a box around the local path planning area use this </span>
<span class="comment">    (You can enable this particular drawing from custom commands </span>
<span class="comment">    which is set up down below in ArServerInfoPath) */</span>
  ArDrawingData drawingDataP(<span class="stringliteral">&quot;polyLine&quot;</span>, ArColor(200,200,200), 1, 75);
  ArFunctor2C&lt;ArPathPlanningTask, ArServerClient *, ArNetPacket *&gt; 
    drawingFunctorP(&amp;pathTask, &amp;<a name="a19"></a><a class="codeRef" doxygen="BaseArnl.tag:../BaseArnl-Reference//" href="../BaseArnl-Reference/classArPathPlanningTask.html#afdd2605b2aedfc6299ab9ca9c0800464">ArPathPlanningTask::drawSearchRectangle</a>);
  drawings.addDrawing(&amp;drawingDataP, <span class="stringliteral">&quot;Local Plan Area&quot;</span>, &amp;drawingFunctorP); 

  <span class="comment">/* Draw a box showing the safety clearance used by the path planning task to */</span>
  drawings.addDrawing(
    <span class="keyword">new</span> ArDrawingData(<span class="stringliteral">&quot;polySegments&quot;</span>, ArColor(166, 166, 166), 1, 60, 100, <span class="stringliteral">&quot;DefaultOn&quot;</span>),
    <span class="stringliteral">&quot;Path Planning Clearances&quot;</span>,
    <span class="keyword">new</span> ArFunctor2C&lt;ArPathPlanningTask, ArServerClient*, ArNetPacket*&gt;(&amp;pathTask, &amp;<a name="a20"></a><a class="codeRef" doxygen="BaseArnl.tag:../BaseArnl-Reference//" href="../BaseArnl-Reference/classArPathPlanningTask.html#a5209bdcce25df07242695f77c20096f3">ArPathPlanningTask::drawRobotBounds</a>)
  );

  <span class="comment">/* Show the sample points used by MCL */</span>
  ArDrawingData drawingDataL(<span class="stringliteral">&quot;polyDots&quot;</span>, ArColor(0,255,0), 100, 75);
  ArFunctor2C&lt;ArLocalizationTask, ArServerClient *, ArNetPacket *&gt; 
    drawingFunctorL(&amp;locTask, &amp;<a name="a21"></a><a class="code" href="classArLocalizationTask.html#a106eada91144e31e6c9999f2130bb98f" title="Draws range data used for localization.">ArLocalizationTask::drawRangePoints</a>);
  drawings.addDrawing(&amp;drawingDataL, <span class="stringliteral">&quot;Localization Points&quot;</span>, &amp;drawingFunctorL);


  <span class="comment">// &quot;Custom&quot; commands. You can add your own custom commands here, they will</span>
  <span class="comment">// be available in MobileEyes&#39; custom commands (enable in the toolbar or</span>
  <span class="comment">// access through Robot Tools)</span>
  ArServerHandlerCommands commands(&amp;server);


  <span class="comment">// These provide various kinds of information to the client:</span>
  ArServerInfoRobot serverInfoRobot(&amp;server, &amp;robot);
  ArServerInfoSensor serverInfoSensor(&amp;server, &amp;robot);
  <a name="_a22"></a><a class="codeRef" doxygen="BaseArnl.tag:../BaseArnl-Reference//" href="../BaseArnl-Reference/classArServerInfoPath.html">ArServerInfoPath</a> serverInfoPath(&amp;server, &amp;robot, &amp;pathTask);
  serverInfoPath.addSearchRectangleDrawing(&amp;drawings);
  serverInfoPath.addControlCommands(&amp;commands);

  <span class="comment">// Provides localization info and allows the client (MobileEyes) to relocalize at a given</span>
  <span class="comment">// pose:</span>
  <a name="_a23"></a><a class="codeRef" doxygen="BaseArnl.tag:../BaseArnl-Reference//" href="../BaseArnl-Reference/classArServerInfoLocalization.html">ArServerInfoLocalization</a> serverInfoLocalization(&amp;server, &amp;robot, &amp;locTask);
  <a name="_a24"></a><a class="codeRef" doxygen="BaseArnl.tag:../BaseArnl-Reference//" href="../BaseArnl-Reference/classArServerHandlerLocalization.html">ArServerHandlerLocalization</a> serverLocHandler(&amp;server, &amp;robot, &amp;locTask);

  <span class="comment">// If you&#39;re using MobileSim, ArServerHandlerLocalization sends it a command</span>
  <span class="comment">// to move the robot&#39;s true pose if you manually do a localization through </span>
  <span class="comment">// MobileEyes.  To disable that behavior, use this constructor call instead:</span>
  <span class="comment">// ArServerHandlerLocalization serverLocHandler(&amp;server, &amp;robot, true, false);</span>
  <span class="comment">// The fifth argument determines whether to send the command to MobileSim.</span>

  <span class="comment">// Provide the map to the client (and related controls):</span>
  ArServerHandlerMap serverMap(&amp;server, &amp;map);

  <span class="comment">// These objects add some simple (custom) commands to &#39;commands&#39; for testing and debugging:</span>
  ArServerSimpleComUC uCCommands(&amp;commands, &amp;robot);                   <span class="comment">// Send any command to the microcontroller</span>
  ArServerSimpleComMovementLogging loggingCommands(&amp;commands, &amp;robot); <span class="comment">// configure logging</span>
  ArServerSimpleComLogRobotConfig configCommands(&amp;commands, &amp;robot);   <span class="comment">// trigger logging of the robot config parameters</span>
<span class="comment">//  ArServerSimpleServerCommands serverCommands(&amp;commands, &amp;server);     // monitor networking behavior (track packets sent etc.)</span>


  <span class="comment">// service that allows the client to monitor the communication link status</span>
  <span class="comment">// between the robot and the client.</span>
  <span class="comment">//</span>
  ArServerHandlerCommMonitor handlerCommMonitor(&amp;server);



  <span class="comment">// service that allows client to change configuration parameters in ArConfig </span>
  ArServerHandlerConfig handlerConfig(&amp;server, Aria::getConfig(),
                      Arnl::getTypicalDefaultParamFileName(),
                      Aria::getDirectory());


  <span class="comment">// This service causes the client to show simple dialog boxes</span>
  ArServerHandlerPopup popupServer(&amp;server);

  <span class="comment">// Monitor the robot for current state such as if the motors are disabled,</span>
  <span class="comment">// indicate this state by various means and show a popup dialog on clients</span>
  <span class="comment">// if user confirmation is needed.</span>
  <span class="comment">// (Namely, some robots  disable motors automatically on various error conditions,</span>
  <span class="comment">// and we want the user to manually re-enable them after resolving the</span>
  <span class="comment">// problem)</span>
  RobotMonitor robotMonitor(&amp;robot, &amp;popupServer);



  <span class="comment">/* Set up the possible modes for remote control from a client such as</span>
<span class="comment">   * MobileEyes:</span>
<span class="comment">   */</span>

  <span class="comment">// Mode To go to a goal or other specific point:</span>
  <a name="_a25"></a><a class="codeRef" doxygen="BaseArnl.tag:../BaseArnl-Reference//" href="../BaseArnl-Reference/classArServerModeGoto.html">ArServerModeGoto</a> modeGoto(&amp;server, &amp;robot, &amp;pathTask, &amp;map,
                locTask.getRobotHome(),
                locTask.getRobotHomeCallback());

  <span class="comment">// Add a special command to Custom Commands that tours a list of goals rather</span>
  <span class="comment">// than all:</span>
  modeGoto.<a name="a26"></a><a class="codeRef" doxygen="BaseArnl.tag:../BaseArnl-Reference//" href="../BaseArnl-Reference/classArServerModeGoto.html#afbd42b7b40058cd0c2f849103a40e9b8">addTourGoalsInListSimpleCommand</a>(&amp;commands);

  <span class="comment">// Mode To stop and remain stopped:</span>
  ArServerModeStop modeStop(&amp;server, &amp;robot);

  <span class="comment">// Cause the sonar to turn off automatically</span>
  <span class="comment">// when the robot is stopped, and turn it back on when commands to move</span>
  <span class="comment">// are sent. (Note, if using SONARNL to localize, then don&#39;t do this</span>
  <span class="comment">// since localization may get lost)</span>
  ArSonarAutoDisabler sonarAutoDisabler(&amp;robot);

  <span class="comment">// Teleoperation modes To drive by keyboard, joystick, etc:</span>
  ArServerModeRatioDrive modeRatioDrive(&amp;server, &amp;robot);  
<span class="comment">//  ArServerModeDrive modeDrive(&amp;server, &amp;robot);            // Older mode for compatability</span>



  <span class="comment">// Prevent normal teleoperation driving if localization is lost using</span>
  <span class="comment">// a high-priority action, which enables itself when the particular mode is</span>
  <span class="comment">// active.</span>
  <span class="comment">// (You have to enter unsafe drive mode to drive when lost.)</span>
  <a class="codeRef" doxygen="BaseArnl.tag:../BaseArnl-Reference//" href="../BaseArnl-Reference/classArActionLost.html">ArActionLost</a> actionLostRatioDrive(&amp;locTask, &amp;pathTask, &amp;modeRatioDrive);
  modeRatioDrive.getActionGroup()-&gt;addAction(&amp;actionLostRatioDrive, 110);

  <span class="comment">// Add drive mode section to the configuration, and also some custom (simple) commands:</span>
  modeRatioDrive.addToConfig(Aria::getConfig(), <span class="stringliteral">&quot;Teleop settings&quot;</span>);
  modeRatioDrive.addControlCommands(&amp;commands);

  <span class="comment">// Wander mode (also prevent wandering if lost):</span>
  ArServerModeWander modeWander(&amp;server, &amp;robot);
  <a class="codeRef" doxygen="BaseArnl.tag:../BaseArnl-Reference//" href="../BaseArnl-Reference/classArActionLost.html">ArActionLost</a> actionLostWander(&amp;locTask, &amp;pathTask, &amp;modeWander);
  modeWander.getActionGroup()-&gt;addAction(&amp;actionLostWander, 110);

  <span class="comment">// Tool to log data periodically to a file</span>
  ArDataLogger dataLogger(&amp;robot, <span class="stringliteral">&quot;datalog.txt&quot;</span>);
  dataLogger.addToConfig(Aria::getConfig()); <span class="comment">// make it configurable through ArConfig</span>

  <span class="comment">// Automatically add anything from the global info group to the data logger.</span>
  Aria::getInfoGroup()-&gt;addAddStringCallback(dataLogger.getAddStringFunctor());

  <span class="comment">// This provides a small table of interesting information for the client</span>
  <span class="comment">// to display to the operator. You can add your own callbacks to show any</span>
  <span class="comment">// data you want.</span>
  ArServerInfoStrings stringInfo(&amp;server);
  Aria::getInfoGroup()-&gt;addAddStringCallback(stringInfo.getAddStringFunctor());
  
  <span class="comment">// The following statements add fields to a set of informational data called</span>
  <span class="comment">// the InfoGroup. These are served to MobileEyes for displayi (turn on by enabling Details</span>
  <span class="comment">// and Custom Details in the View menu of MobileEyes.)</span>

  Aria::getInfoGroup()-&gt;addStringInt(
      <span class="stringliteral">&quot;Motor Packet Count&quot;</span>, 10, 
      <span class="keyword">new</span> ArConstRetFunctorC&lt;int, ArRobot&gt;(&amp;robot, 
                           &amp;ArRobot::getMotorPacCount));

  Aria::getInfoGroup()-&gt;addStringDouble(
      <span class="stringliteral">&quot;Laser Localization Score&quot;</span>, 8, 
      <span class="keyword">new</span> ArRetFunctorC&lt;double, ArLocalizationTask&gt;(
          &amp;locTask, &amp;<a name="a27"></a><a class="code" href="classArLocalizationTask.html#a17ff3d74dfa7cd4955c284a954e2ba03" title="Gets the higher of MCL and Reflector based localization.">ArLocalizationTask::getLocalizationScore</a>),
      <span class="stringliteral">&quot;%.03f&quot;</span>);
  Aria::getInfoGroup()-&gt;addStringInt(
      <span class="stringliteral">&quot;Laser Loc Num Samples&quot;</span>, 8, 
      <span class="keyword">new</span> ArRetFunctorC&lt;int, ArLocalizationTask&gt;(
          &amp;locTask, &amp;<a name="a28"></a><a class="code" href="classArLocalizationTask.html#af05fb6f78dbb52b3937698ef467e3d1a" title="Get the variable number of samples if adjusted during move.">ArLocalizationTask::getCurrentNumSamples</a>),
      <span class="stringliteral">&quot;%4d&quot;</span>);


  <span class="comment">// Display gyro status if gyro is enabled and is being handled by the firmware (gyro types 2, 3, or 4).</span>
  <span class="comment">// (If the firmware detects an error communicating with the gyro or IMU it</span>
  <span class="comment">// returns a flag, and stops using it.)</span>
  <span class="comment">// (This gyro type parameter, and fault flag, are only in ARCOS, not Seekur firmware)</span>
  <span class="keywordflow">if</span>(robot.getOrigRobotConfig() &amp;&amp; robot.getOrigRobotConfig()-&gt;getGyroType() &gt; 1)
  {
    Aria::getInfoGroup()-&gt;addStringString(
          <span class="stringliteral">&quot;Gyro/IMU Status&quot;</span>, 10,
          <span class="keyword">new</span> ArGlobalRetFunctor1&lt;const char*, ArRobot*&gt;(&amp;getGyroStatusString, &amp;robot)
      );
  }

  <span class="comment">// Display system CPU and wireless network status</span>
  ArSystemStatus::startPeriodicUpdate(1000); <span class="comment">// update every 1 second</span>
  Aria::getInfoGroup()-&gt;addStringDouble(<span class="stringliteral">&quot;CPU Use&quot;</span>, 10, ArSystemStatus::getCPUPercentFunctor(), <span class="stringliteral">&quot;% 4.0f%%&quot;</span>);
  Aria::getInfoGroup()-&gt;addStringInt(<span class="stringliteral">&quot;Wireless Link Quality&quot;</span>, 9, ArSystemStatus::getWirelessLinkQualityFunctor(), <span class="stringliteral">&quot;%d&quot;</span>);
  Aria::getInfoGroup()-&gt;addStringInt(<span class="stringliteral">&quot;Wireless Link Noise&quot;</span>, 9, ArSystemStatus::getWirelessLinkNoiseFunctor(), <span class="stringliteral">&quot;%d&quot;</span>);
  Aria::getInfoGroup()-&gt;addStringInt(<span class="stringliteral">&quot;Wireless Signal&quot;</span>, 9, ArSystemStatus::getWirelessLinkSignalFunctor(), <span class="stringliteral">&quot;%d&quot;</span>);
  

  <span class="comment">// stats on how far its driven since software started</span>
  Aria::getInfoGroup()-&gt;addStringDouble(<span class="stringliteral">&quot;Distance Travelled (m)&quot;</span>, 20, <span class="keyword">new</span> ArRetFunctorC&lt;double, ArRobot&gt;(&amp;robot, &amp;ArRobot::getOdometerDistanceMeters), <span class="stringliteral">&quot;%.2f&quot;</span>);
  Aria::getInfoGroup()-&gt;addStringDouble(<span class="stringliteral">&quot;Run time (min)&quot;</span>, 20, <span class="keyword">new</span>
ArRetFunctorC&lt;double, ArRobot&gt;(&amp;robot, &amp;ArRobot::getOdometerTimeMinutes),
<span class="stringliteral">&quot;%.2f&quot;</span>);


  <span class="comment">// Setup the dock if there is a docking system on board.</span>
  <a name="_a29"></a><a class="code" href="classArServerModeDock.html" title="Base class to manage docking.">ArServerModeDock</a> *modeDock = NULL;
  modeDock = <a name="a30"></a><a class="code" href="classArServerModeDock.html#aa53132f83bb440cd4f31156359adcde5" title="This will create a dock of the appropriate type for the robot.">ArServerModeDock::createDock</a>(&amp;server, &amp;robot, &amp;locTask, 
                      &amp;pathTask);
  <span class="keywordflow">if</span> (modeDock != NULL)
  {
    modeDock-&gt;<a name="a31"></a><a class="code" href="classArServerModeDock.html#a652e2ec28feb5fa0a8614499c0bf29f2" title="Sees if the robot is already docked and activates itself if it is (subclass should implement)...">checkDock</a>();
    modeDock-&gt;addAsDefaultMode();
    modeDock-&gt;<a name="a32"></a><a class="code" href="classArServerModeDock.html#a130ef72d4916d9d8e2d0f693ee045dfe" title="Adds the docking information to the given config.">addToConfig</a>(Aria::getConfig());
    modeDock-&gt;<a name="a33"></a><a class="code" href="classArServerModeDock.html#ab290d9d35222c23cb431b28003598a50" title="Adds simple commands to.">addControlCommands</a>(&amp;commands);
  }




  <span class="comment">// Make Stop mode the default (If current mode deactivates without entering</span>
  <span class="comment">// a new mode, then Stop Mode will be selected)</span>
  modeStop.addAsDefaultMode();
    <span class="comment">// TODO move up near where stop mode is created?</span>





  <span class="comment">/* Services that allow the client to initiate scanning with the laser to</span>
<span class="comment">     create maps in Mapper3 (So not possible with SONARNL): */</span>

  ArServerHandlerMapping handlerMapping(&amp;server, &amp;robot, firstLaser, 
                    fileDir, <span class="stringliteral">&quot;&quot;</span>, <span class="keyword">true</span>);

  <span class="comment">// make laser localization stop while mapping</span>
  handlerMapping.addMappingStartCallback(
      <span class="keyword">new</span> ArFunctor1C&lt;ArLocalizationTask, bool&gt;
      (&amp;locTask, &amp;<a name="a34"></a><a class="code" href="classArLocalizationTask.html#a8347691797bdba24fa53bb668be7d12e" title="Sets the idle flag.">ArLocalizationTask::setIdleFlag</a>, <span class="keyword">true</span>));

  <span class="comment">// and then make it start again when we&#39;re doine</span>
  handlerMapping.addMappingEndCallback(
      <span class="keyword">new</span> ArFunctor1C&lt;ArLocalizationTask, bool&gt;
      (&amp;locTask, &amp;<a class="code" href="classArLocalizationTask.html#a8347691797bdba24fa53bb668be7d12e" title="Sets the idle flag.">ArLocalizationTask::setIdleFlag</a>, <span class="keyword">false</span>));


  <span class="comment">// Make it so our &quot;lost&quot; actions don&#39;t stop us while mapping</span>
  handlerMapping.addMappingStartCallback(actionLostPath.getDisableCB());
  handlerMapping.addMappingStartCallback(actionLostRatioDrive.getDisableCB());
  handlerMapping.addMappingStartCallback(actionLostWander.getDisableCB());

  <span class="comment">// And then let them make us stop as usual when done mapping</span>
  handlerMapping.addMappingEndCallback(actionLostPath.getEnableCB());
  handlerMapping.addMappingEndCallback(actionLostRatioDrive.getEnableCB());
  handlerMapping.addMappingEndCallback(actionLostWander.getEnableCB());

  <span class="comment">// don&#39;t let forbidden lines show up as obstacles while mapping</span>
  <span class="comment">// (they&#39;ll just interfere with driving while mapping, and localization is off anyway)</span>
  handlerMapping.addMappingStartCallback(forbidden.getDisableCB());

  <span class="comment">// let forbidden lines show up as obstacles again as usual after mapping</span>
  handlerMapping.addMappingEndCallback(forbidden.getEnableCB());


  <span class="comment">/*</span>
<span class="comment">  // If we are on a simulator, move the robot back to its starting position,</span>
<span class="comment">  // and reset its odometry.</span>
<span class="comment">  // This will allow localizeRobotAtHomeBlocking() below will (probably) work (it</span>
<span class="comment">  // tries current odometry (which will be 0,0,0) and all the map</span>
<span class="comment">  // home points.</span>
<span class="comment">  // (Ignored by a real robot)</span>
<span class="comment">  //robot.com(ArCommands::SIM_RESET);</span>
<span class="comment">  */</span>


  <span class="comment">// create a pose storage class, this will let the program keep track</span>
  <span class="comment">// of where the robot is between runs...  after we try and restore</span>
  <span class="comment">// from this file it will start saving the robot&#39;s pose into the</span>
  <span class="comment">// file</span>
  <a name="_a35"></a><a class="codeRef" doxygen="BaseArnl.tag:../BaseArnl-Reference//" href="../BaseArnl-Reference/classArPoseStorage.html">ArPoseStorage</a> poseStorage(&amp;robot);
  <span class="keywordflow">if</span> (poseStorage.restorePose(<span class="stringliteral">&quot;robotPose&quot;</span>))
    serverLocHandler.setSimPose(robot.getPose());
  <span class="comment">//else</span>
 <span class="comment">//   robot.com(ArCommands::SIM_RESET);</span>



  <span class="comment">/* File transfer services: */</span>
  
<span class="preprocessor">#ifdef WIN32</span>
<span class="preprocessor"></span>  <span class="comment">// Not implemented for Windows yet.</span>
  ArLog::log(ArLog::Normal, <span class="stringliteral">&quot;Note, file upload/download services are not implemented for Windows; not enabling them.&quot;</span>);
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>  <span class="comment">// This block will allow you to set up where you get and put files</span>
  <span class="comment">// to/from, just comment them out if you don&#39;t want this to happen</span>
  <span class="comment">// /*</span>
  ArServerFileLister fileLister(&amp;server, fileDir);
  ArServerFileToClient fileToClient(&amp;server, fileDir);
  ArServerFileFromClient fileFromClient(&amp;server, fileDir, <span class="stringliteral">&quot;/tmp&quot;</span>);
  ArServerDeleteFileOnServer deleteFileOnServer(&amp;server, fileDir);
  <span class="comment">// */</span>
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
    <span class="comment">/* Video image streaming, and camera controls (Requires SAVserver or ACTS) */</span>

  <span class="comment">// Forward one video stream if either ACTS, ArVideo videoSubServer, </span>
  <span class="comment">// or SAV server are running.</span>
  <span class="comment">// ArHybridForwarderVideo allows this program to be separate from the ArVideo</span>
  <span class="comment">// library. You could replace videoForwarder and the PTZ connection code below</span>
  <span class="comment">// with a call to ArVideo::createVideoServers(), and link the program to the</span>
  <span class="comment">// ArVideo library if you want to include video capture in the same program</span>
  <span class="comment">// as robot control.</span>
  ArHybridForwarderVideo videoForwarder(&amp;server, <span class="stringliteral">&quot;localhost&quot;</span>, 7070);
  
  <span class="comment">// connect to first configured camera PTZ controls (in robot parameter file and</span>
  <span class="comment">// command line options)</span>
  ptzConnector.connect();
  ArServerHandlerCamera *cameraServer = NULL;
  ArCameraCollection cameraCollection;
  ArPTZ *ptz = ptzConnector.getPTZ(0);
  <span class="keywordflow">if</span>(ptz)
  {
    ArLog::log(ArLog::Normal, <span class="stringliteral">&quot;Connected to PTZ Camera&quot;</span>);
    cameraCollection.addCamera(<span class="stringliteral">&quot;Camera1&quot;</span>, ptz-&gt;getTypeName(), <span class="stringliteral">&quot;Camera&quot;</span>, ptz-&gt;getTypeName());

    videoForwarder.setCameraName(<span class="stringliteral">&quot;Camera1&quot;</span>);
    videoForwarder.addToCameraCollection(cameraCollection);

    cameraServer = <span class="keyword">new</span> ArServerHandlerCamera(<span class="stringliteral">&quot;Camera1&quot;</span>, 
                                                   &amp;server, 
                                                         &amp;robot,
                                                         ptz, 
                                                         &amp;cameraCollection);

    <span class="comment">// ArServerHandlerCamera has a special feature that continuously moves the</span>
    <span class="comment">// camera to look at a position. This is an example of how to use that to </span>
    <span class="comment">// look at the path planning task&#39;s next goal via its callbacks. You can </span>
    <span class="comment">// also set the ArServerHandhlerCamera to look at any map position instead.</span>
    pathTask.addNewGoalCB(
        <span class="keyword">new</span> ArFunctor1C&lt;ArServerHandlerCamera, ArPose&gt;(
            cameraServer, 
            &amp;ArServerHandlerCamera::cameraModeLookAtGoalSetGoal));
    pathTask.addGoalFinishedCB(
        <span class="keyword">new</span> ArFunctorC&lt;ArServerHandlerCamera&gt;(
            cameraServer, 
            &amp;ArServerHandlerCamera::cameraModeLookAtGoalClearGoal));

  } 

  <span class="comment">// Allows client to find any camera servers created above</span>
  ArServerHandlerCameraCollection cameraCollectionServer(&amp;server, &amp;cameraCollection);



    <span class="comment">/* Load configuration values, map, and begin! */</span>

  
  <span class="comment">// When parsing the configuration file, also look at the program&#39;s command line options </span>
  <span class="comment">// from the command-line argument parser as well as the configuration file.</span>
  <span class="comment">// (So you can use any argument on the command line, namely -map.) </span>
  Aria::getConfig()-&gt;useArgumentParser(&amp;parser);

  <span class="comment">// Read in parameter files.</span>
  ArLog::log(ArLog::Normal, <span class="stringliteral">&quot;Loading config file %s%s into ArConfig...&quot;</span>, Aria::getDirectory(), Arnl::getTypicalParamFileName());
  <span class="keywordflow">if</span> (!Aria::getConfig()-&gt;parseFile(Arnl::getTypicalParamFileName()))
  {
    ArLog::log(ArLog::Normal, <span class="stringliteral">&quot;Could not load ARNL configuration file. Set ARNL environment variable to use non-default installation director.y&quot;</span>);
    Aria::exit(5);
  }

  <span class="comment">// Warn about unknown params.</span>
  <span class="keywordflow">if</span> (!simpleOpener.checkAndLog() || !parser.checkHelpAndWarnUnparsed())
  {
    logOptions(argv[0]);
    Aria::exit(6);
  }

  <span class="comment">// Warn if there is no map</span>
  <span class="keywordflow">if</span> (map.getFileName() == NULL || strlen(map.getFileName()) &lt;= 0)
  {
    ArLog::log(ArLog::Normal, <span class="stringliteral">&quot;&quot;</span>);
    ArLog::log(ArLog::Normal, <span class="stringliteral">&quot;### No map file is set up, you can make a map with the following procedure&quot;</span>);
    ArLog::log(ArLog::Normal, <span class="stringliteral">&quot;   0) You can find this information in README.txt or docs/Mapping.txt&quot;</span>);
    ArLog::log(ArLog::Normal, <span class="stringliteral">&quot;   1) Connect to this server with MobileEyes&quot;</span>);
    ArLog::log(ArLog::Normal, <span class="stringliteral">&quot;   2) Go to Tools-&gt;Map Creation-&gt;Start Scan&quot;</span>);
    ArLog::log(ArLog::Normal, <span class="stringliteral">&quot;   3) Give the map a name and hit okay&quot;</span>);
    ArLog::log(ArLog::Normal, <span class="stringliteral">&quot;   4) Drive the robot around your space (see docs/Mapping.txt&quot;</span>);
    ArLog::log(ArLog::Normal, <span class="stringliteral">&quot;   5) Go to Tools-&gt;Map Creation-&gt;Stop Scan&quot;</span>);
    ArLog::log(ArLog::Normal, <span class="stringliteral">&quot;   6) Start up Mapper3&quot;</span>);
    ArLog::log(ArLog::Normal, <span class="stringliteral">&quot;   7) Go to File-&gt;Open on Robot&quot;</span>);
    ArLog::log(ArLog::Normal, <span class="stringliteral">&quot;   8) Select the .2d you created&quot;</span>);
    ArLog::log(ArLog::Normal, <span class="stringliteral">&quot;   9) Create a .map&quot;</span>);
    ArLog::log(ArLog::Normal, <span class="stringliteral">&quot;  10) Go to File-&gt;Save on Robot&quot;</span>);
    ArLog::log(ArLog::Normal, <span class="stringliteral">&quot;  11) In MobileEyes, go to Tools-&gt;Robot Config&quot;</span>);
    ArLog::log(ArLog::Normal, <span class="stringliteral">&quot;  12) Choose the Files section&quot;</span>);
    ArLog::log(ArLog::Normal, <span class="stringliteral">&quot;  13) Enter the path and name of your new .map file for the value of the Map parameter.&quot;</span>);
    ArLog::log(ArLog::Normal, <span class="stringliteral">&quot;  14) Press OK and your new map should become the map used&quot;</span>);
    ArLog::log(ArLog::Normal, <span class="stringliteral">&quot;&quot;</span>);    
  }

  <span class="comment">// Print a log message notifying user of the directory for map files</span>
  ArLog::log(ArLog::Normal, <span class="stringliteral">&quot;&quot;</span>);
  ArLog::log(ArLog::Normal, 
         <span class="stringliteral">&quot;Directory for maps and file serving: %s&quot;</span>, fileDir);
  
  ArLog::log(ArLog::Normal, <span class="stringliteral">&quot;See the ARNL README.txt for more information&quot;</span>);
  ArLog::log(ArLog::Normal, <span class="stringliteral">&quot;&quot;</span>);

  <span class="comment">// Do an initial localization of the robot. ARNL and SONARNL try all the home points</span>
  <span class="comment">// in the map, as well as the robot&#39;s current odometric position, as possible</span>
  <span class="comment">// places the robot is likely to be at startup.   If successful, it will</span>
  <span class="comment">// also save the position it found to be the best localized position as the</span>
  <span class="comment">// &quot;Home&quot; position, which can be obtained from the localization task (and is</span>
  <span class="comment">// used by the &quot;Go to home&quot; network request).</span>
  <span class="comment">// MOGS instead just initializes at the current GPS position.</span>
  <span class="comment">// (You will stil have to drive the robot so it can determine the robot&#39;s</span>
  <span class="comment">// heading, however. See GPS Mapping instructions.)</span>
  locTask.localizeRobotAtHomeBlocking();
  
  <span class="comment">// Let the client switch manager (for multirobot) spin off into its own thread</span>
  <span class="comment">// TODO move to multirobot example?</span>
  clientSwitch.runAsync();

  <span class="comment">// Start the networking server&#39;s thread</span>
  server.runAsync();


  <span class="comment">// Add a key handler so that you can exit by pressing</span>
  <span class="comment">// escape. Note that this key handler, however, prevents this program from</span>
  <span class="comment">// running in the background (e.g. as a system daemon or run from </span>
  <span class="comment">// the shell with &quot;&amp;&quot;) -- it will lock up trying to read the keys; </span>
  <span class="comment">// remove this if you wish to be able to run this program in the background.</span>
  ArKeyHandler *keyHandler;
  <span class="keywordflow">if</span> ((keyHandler = Aria::getKeyHandler()) == NULL)
  {
    keyHandler = <span class="keyword">new</span> ArKeyHandler;
    Aria::setKeyHandler(keyHandler);
    robot.lock();
    robot.attachKeyHandler(keyHandler);
    robot.unlock();
    puts(<span class="stringliteral">&quot;Server running. To exit, press escape.&quot;</span>);
  }

  <span class="comment">// Enable the motors and wait until the robot exits (disconnection, etc.) or this program is</span>
  <span class="comment">// canceled.</span>
  robot.enableMotors();
  robot.waitForRunExit();
  Aria::exit(0);
}

</pre></div> </div><!-- contents -->
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>

    <li class="footer">Generated on Thu Oct 30 2014 14:13:22 for ARNL by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
